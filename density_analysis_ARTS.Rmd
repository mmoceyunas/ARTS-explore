---
title: "density_analysis_ARTS"
output: html_document
date: "2024-07-18"
---

## Load library and dataset
```{r}
library(terra)
library(sf)
library(ggplot2)
library(spatstat)
library(nngeo)
library(tidyverse) 

nitze_sf <- st_read("nitze_image_bounding_boxes/nitzeTrainingLabel2023_Negative_meta3.shp")
mocey_sf <- st_read("Moceyunas_box.geojson")

arts_sf = st_read("ARTS_main_dataset_V.2.0.0.geojson")
```
```{r make valid}
if (!all(st_is_valid(arts_sf))) {
  arts_sf = st_make_valid(arts_sf)
}
```

## Simply Nitze and Intersect
```{r simplify overlap in nitze_sf}
nitze_bboxes = nitze_sf |>
  st_remove_holes() |>
  st_union() |>
  st_as_sf() |>
  rename(geometry = x)

mocey_bboxes = mocey_sf |>
  st_remove_holes() |>
  st_union() |>
  st_as_sf() |>
  rename(geometry = x)

bboxes <- rbind(nitze_bboxes, mocey_bboxes)

bboxes = bboxes |>
  st_remove_holes() |>
  st_union() |>
  st_as_sf() |>
  rename(geometry = x)

plot(bboxes)

nitze_bbox_2 = nitze_sf |> #example slice
  st_remove_holes() |>
  st_union() |>
  st_cast('POLYGON') |>
  st_as_sf() |>
  rename(geometry = x)|>
  slice(2)
```
```{r intersection}
arts_bboxes = arts_sf |>
  filter(
    map_lgl(
      st_intersects(arts_sf, bboxes, sparse = TRUE), 
      ~ length(.x) > 0
    )
  )

arts_nitze_2 = arts_sf |> #example slice
  filter(
    map_lgl(
      st_intersects(arts_sf, nitze_bbox_2, sparse = TRUE), 
      ~ length(.x) > 0
    )
  )
```
```{r check with plots}
ggplot() + 
  geom_sf(data = bboxes,
          aes(color = 'BBoxes',
              fill = 'BBoxes')) + 
  geom_sf(data = arts_bboxes, 
           aes(color = 'ARTS',
               fill = 'ARTS'),
          size = 0.2) +
  scale_color_manual(name = 'Dataset',
                     values = c('red', 'black')) +
  scale_fill_manual(name = 'Dataset',
                     values = c('transparent', 'transparent')) +
  theme(legend.position = 'bottom')

ggplot() +                      #example slice
  geom_sf(data = nitze_bbox_2,
          aes(color = 'Nitze BBoxes',
              fill = 'Nitze BBoxes')) + 
  geom_sf(data = arts_nitze_2, 
           aes(color = 'ARTS',
               fill = 'ARTS'),
          size = 0.2) +
  scale_color_manual(name = 'Dataset',
                     values = c('red', 'black')) +
  scale_fill_manual(name = 'Dataset',
                     values = c('transparent', 'transparent')) +
  theme(legend.position = 'bottom')
```

## Convert to Centroids
```{r convert to points}
arts_bboxes_centroids = arts_bboxes |>
  st_drop_geometry() |>
    mutate(
        geometry = map2(
            as.numeric(CentroidLon),
            as.numeric(CentroidLat),
            ~ st_point(c(.x, .y))
            ) |>
            st_sfc(crs = 4326) |> 
            st_transform(crs = 3413)
        ) |>
  st_as_sf(crs = 3413) |>
  select(geometry)
  # select(UID) # ppp uses one column of the dataframe as labels ("marks"), and this column can be used to link back to the original dataset, if necessary

arts_nitze_centroids_2 = arts_nitze_2 |>  #example slice
  st_drop_geometry() |>
    mutate(
        geometry = map2(
            as.numeric(CentroidLon),
            as.numeric(CentroidLat),
            ~ st_point(c(.x, .y))
            ) |>
            st_sfc(crs = 4326) |> 
            st_transform(crs = 3413) 
        ) |>
  st_as_sf(crs = 3413) |>
  select(geometry)
```

```{r convert to ppp}
centroids_ppp = bboxes |>
  rbind(arts_bboxes_centroids) |> # add Nitze bboxes as first row prior to conversion to ppp so that it will be taken as the window for further analyses
  as.ppp()

centroids_ppp_2 = nitze_bbox_2 |> #example slice
  rbind(arts_nitze_centroids_2) |> 
  as.ppp()
```

```{r uniqueness necessary?}
u_c_ppp <- unique(centroids_ppp, warn = TRUE)
u_c_ppp_2 <- unique(centroids_ppp_2, warn = TRUE) #example slice
```

```{r data prep}
marks(u_c_ppp)  <- NULL
bboxes_owin <- as.owin(bboxes)
Window(u_c_ppp) <- bboxes_owin

marks(u_centroids_ppp_2)  <- NULL     #example slice
nitze_bbox_2_owin <- as.owin(nitze_bbox_2)
Window(u_centroids_ppp_2) <- nitze_bbox_2_owin
plot(u_centroids_ppp_2, main=NULL, cols=rgb(0,0,0,.2), pch=20)

#rescale
ppp_km <- rescale(u_c_ppp, 1000, "km")
ppp2_km <- rescale(u_c_ppp2, 1000, "km")
bboxes_owin_km <- rescale(bboxes_owin, 1000, "km")
bbox2_owin_km <- rescale(nitze_bbox_2_owin, 1000, "km")
```

## All Kernel Density

### No Covariate

Estimate bandwidth
```{r}
sigma_value = bw.diggle(ppp_km) #suggested if detecting pattern of predominantly tight clusters
plot(sigma_value)
```

```{r}
sigma_value = bw.ppl(ppp_km) #suggested if detecting pattern of predominantly tight clusters
plot(sigma_value)
```

```{r default bandwidth}
#density function computes an isotropic kernel intensity estimate of the point patter, bandwidth defines the kernel's window extent

K1 <- density(ppp_km, eps = 1, sigma = sigma_value)
plot(K1, main='RTS density in Nitze bounds', las=1)
contour(K1, add=TRUE)
```

### Covariate Adjusted

```{r prep PCA 1}
pca_r <- rast("pca.tif")

#isolating band and cropping by bounding boxes
band_index <- 1
pca1_r <- pca_r[[band_index]]
pca1 <- crop(x = pca1_r, y = bboxes)
plot(pca1)
pca2 <- pca[[2]]
pca2 <- mask(pca2, bboxes)

#convert to im
as.im.SpatRaster1 <- function(X) {
    X <- X[[1]]
    rs <- terra::res(X)
    e <- as.vector(terra::ext(X))
    out <- list(
        v = as.matrix(X, wide=TRUE)[nrow(X):1, ],
        dim = dim(X)[1:2],
        xrange = e[1:2],
        yrange = e[3:4],
        xstep = rs[1],
        ystep = rs[2],
        xcol = e[1] + (1:ncol(X)) * rs[1] + 0.5 * rs[1],
        yrow = e[4] - (nrow(X):1) * rs[2] + 0.5 * rs[2],
        type = "real",
        units  = list(singular=units(X), plural=units(X), multiplier=1)
    )
    attr(out$units, "class") <- "unitname"
    attr(out, "class") <- "im"
    out
}
pca1_im <- as.im.SpatRaster1(pca1)
class(pca1_im)
hist(pca1_im, main=NULL, las=1)
pca2_im <- as.im.SpatRaster1(pca2)

#rescale
pca1_im_km <-rescale(pca1_im, 1000, "km")
na_count <- sum(is.na(pca1_im_km))
na_count
pca2_im_km <- rescale(pca2_im, 1000, "km")
```

```{r computing rho}
marks(ppp_km) <- NULL
Window(ppp_km) <- bboxes_owin_km

rho <- rhohat(ppp_km, pca1_im_km, method = "ratio", sigma = sigma_value)
plot(rho, las=1, main=NULL)
```

```{r generating map of predicted RTS density if PCA1 was the sole driving process}
pred <- predict(rho)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred, col=cl, las=1, main=NULL, gamma = 0.25)
```

```{r compare output of predicted to observed}
K1 <- density(ppp_km, eps = 1, rule.eps = "adjust.eps")
K1_vs_pred <- pairs(K1, pred, plot = FALSE)

summary(as.data.frame(K1_vs_pred))

plot(K1_vs_pred$pred ~ K1_vs_pred$K1, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```


# Poisson Point Process Model

```{r poisson point process model}
PPM1 <- ppm(u_c_ppp_km ~ pca1_im_km*pca2_im_km)

for (pc2 in seq(-3.5, 4, by = 0.5)) {
  plot(effectfun(PPM1, "pca1_im_km", pca2_im_km = pc2, se.fit=TRUE), main=NULL, 
       las=1, legendargs=list(cex=0.8, xpd=TRUE, inset=c(1.01, 0) ))
}

for (pc1 in seq(-2, 4.5, by = 0.5)) {
  plot(effectfun(PPM1, "pca2_im_km", pca1_im_km = pc1, se.fit=TRUE), main=NULL, 
       las=1, legendargs=list(cex=0.8, xpd=TRUE, inset=c(1.01, 0) ))
}

PPM1_drop <- quad.ppm(PPM1, drop=TRUE) #this step will drop points within the quadrature scheme that had NA-values
PPM1_corrected <- ppm(PPM1_drop ~ pca1_im_km) 
plot(effectfun(PPM1_corrected, "pca1_im_km", se.fit=TRUE), main= "Poisson Point Process Model", 
     las=1)

PPM1_corrected
#lambda(i) = e^(-0.09 + 0.34)
#for every increase in one unit of the PCA1 density, the RTS point density increases by a factor of e^(-0.09 + 0.34) units
```

## Subset Kernel Density

### Pixel Size Troubleshooting

```{r}
for (eps_value in c(1/100, 1/10, 1, 2)) {
  K1.2 <- density(u_c_ppp2_km, eps = eps_value)  #example slice
  plot(K1.2, main=NULL, las=1)
  contour(K1.2, add=TRUE)
}
```

```{r}
K1.2 <- density(u_c_ppp2_km, sigma = bw.scott, eps = 1)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)
```

```{r}
bw.diggle(u_c_ppp2_km) #suggested if detecting single tight cluster in midst of random noise
b = bw.ppl(u_c_ppp2_km) #suggested if detecting pattern of predominantly tight clusters
plot(b)
bw.scott(u_c_ppp2_km)
```

```{r}
for (sigma_value in seq(1,5)) {
  K1.2 <- density(u_c_ppp2_km, sigma = sigma_value, eps = 1)  #example slice
  plot(K1.2, main=NULL, las=1)
  contour(K1.2, add=TRUE)
}
```

```{r}
for (eps_value in c(1/100, 1/10, 1, 2)) {
  rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
  pred.2 <- predict(rho.2)
  plot(pred.2, las=1, main=NULL)
}
```

```{r}
# pca1.2_im_100m = rescale(pca1.2_im, 100, 'hm')
rho.2 <- rhohat(u_centroids_ppp_2, pca1.2_im, method = "ratio")
pred.2 <- predict(rho.2)
plot(pred.2, las=1, main=NULL)
```

```{r}
K1.2 <- density(u_c_ppp2_km)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "reweight")
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
eps_value = 1
K1.2 <- density(u_c_ppp2_km, eps = eps_value)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio")
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
eps_value = 1
K1.2 <- density(u_c_ppp2_km, eps = eps_value)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
eps_value = 1/10
K1.2 <- density(u_c_ppp2_km)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
eps_value = 1/100
K1.2 <- density(u_c_ppp2_km)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
# eps_value = 1/1000
# K1.2 <- density(u_c_ppp2_km)  #example slice
# plot(K1.2, main=NULL, las=1)
# contour(K1.2, add=TRUE)
# 
# pca1.2 = crop(pca, nitze_bbox_2)
# pca1.2_im = as.im.SpatRaster1(pca1.2)
# pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
# rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
# plot(rho.2, las=1, main=NULL)
# 
# pred.2 <- predict(rho.2)
# cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
# plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)
# 
# K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
# summary(as.data.frame(K1_vs_pred.2))
# 
# plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
#      xlab = "Observed intensity", 
#      ylab = "Predicted intensity", 
#      col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

```{r}
eps_value = 1/10
K1.2 <- density(u_c_ppp2_km, eps = eps_value)  #example slice
plot(K1.2, main=NULL, las=1)
contour(K1.2, add=TRUE)

pca1.2 = crop(pca, nitze_bbox_2)
pca1.2_im = as.im.SpatRaster1(pca1.2)
pca1.2_im_km = rescale(pca1.2_im, 1000, 'km')
rho.2 <- rhohat(u_c_ppp2_km, pca1.2_im_km, method = "ratio", eps = eps_value)
plot(rho.2, las=1, main=NULL)

pred.2 <- predict(rho.2)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred.2, col=cl, las=1, main=NULL, gamma = 0.25)

K1_vs_pred.2 <- pairs(K1.2, pred.2, plot = FALSE)
summary(as.data.frame(K1_vs_pred.2))

plot(K1_vs_pred.2$pred.2 ~ K1_vs_pred.2$K1.2, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1)) + abline(a=0, b = 1, col = "red")
```

## Experiment w/ 2 slices combined
```{r make slice} 
nitze_bbox_3 = nitze_sf |> #example slice
  st_remove_holes() |>
  st_union() |>
  st_cast('POLYGON') |>
  st_as_sf() |>
  rename(geometry = x)|>
  slice(18, 19)

nitze_bbox_3 = nitze_bbox_3 |>
  st_remove_holes() |>
  st_union() |>
  st_as_sf() |>
  rename(geometry = x)

plot(nitze_bbox_3)
```
```{r intersection}
arts_nitze_3 = arts_sf |> #example slice
  filter(
    map_lgl(
      st_intersects(arts_sf, nitze_bbox_3, sparse = TRUE), 
      ~ length(.x) > 0
    )
  )
```

```{r convert to centroids}
arts_nitze_centroids_3 = arts_nitze_3 |>  #example slice
  st_drop_geometry() |>
    mutate(
        geometry = map2(
            as.numeric(CentroidLon),
            as.numeric(CentroidLat),
            ~ st_point(c(.x, .y))
            ) |>
            st_sfc(crs = 4326) |> 
            st_transform(crs = 3413) 
        ) |>
  st_as_sf(crs = 3413) |>
  select(geometry)

centroids_ppp_3 = nitze_bbox_3 |>
  rbind(arts_nitze_centroids_3) |> # add Nitze bboxes as first row prior to conversion to ppp so that it will be taken as the window for further analyses
  as.ppp()
```

```{r uniqueness necessary?}
u_centroids_ppp_3 <- unique(centroids_ppp_3, warn = TRUE)
```

```{r data prep}
marks(u_centroids_ppp_3)  <- NULL
nitze_bbox_3_owin <- as.owin(nitze_bbox_3)
Window(u_centroids_ppp_3) <- nitze_bbox_3_owin

#rescale
u_c_ppp3_km <- rescale(u_centroids_ppp_3, 1000, "km")
nitze_bbox_3_km <- rescale(nitze_bbox_3_owin, 1000, "km")
```

```{r kernel density}
plot(density.ppp(u_c_ppp3_km, kernel = "epanechnikov", sigma = 1.167406,edge=T),
     main=paste("RTS Kernel Density Estimate w/ 2 Nitze Slices"))
```

## Kernel density adjusted for covariate w/ slice
```{r prep PCA 1}
#cropping by bounding boxes
pca1_SLICE <- crop(x = pca1, y = nitze_bbox_2)
plot(pca1_SLICE)

#convert to im
pca1_SLICE_im <- as.im.SpatRaster1(pca1_SLICE)
class(pca1_SLICE_im)

#rescale
pca1_SLICE_im_km <- rescale(pca1_SLICE_im, 1000, "km")
plot(pca1_SLICE_im_km)
```

```{r computing rho}
marks(ppp2_km) <- NULL
Window(ppp2_km) <- bbox2_owin_km

rho_SLICE <- rhohat(ppp2_km, pca1_SLICE_im_km, method = "ratio")
plot(rho_SLICE, las=1, main= "rho VS covariate")
```

```{r generating map of predicted RTS density if PCA1 was the sole driving process}
pred_SLICE <- predict(rho_SLICE)
cl_SLICE   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred_SLICE, col=cl_SLICE, las=1, main=NULL, gamma = 0.25)
```

```{r compare output of predicted to observed}
K1_SLICE <- density(ppp2_km, eps = 1, rule.eps = "adjust.eps")
K1_SLICEvs_pred <- pairs(K1_SLICE, pred_SLICE, plot = FALSE)
plot(K1_SLICEvs_pred$pred_SLICE ~ K1_SLICEvs_pred$K1_SLICE, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,0.1))

summary(as.data.frame(K1_SLICEvs_pred))

plot(K1_SLICEvs_pred$pred_SLICE ~ K1_SLICEvs_pred$K1_SLICE, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,.2),
     main = "Predicted intensity vs Observed intensity w/ 1 to 1 diagonal") + abline(a=0, b = 1, col = "red")


dim(pred_SLICE)
dim(K1_SLICE)
```

```{r poisson point process model}
PPM1_SLICE <- ppm(ppp2_km ~ pca1_SLICE_im_km)
plot(effectfun(PPM1_SLICE, "pca1_SLICE_im_km", se.fit=TRUE), main=NULL, 
     las=1)

PPM1_SLICE_drop <- quad.ppm(PPM1_SLICE, drop=TRUE) #this step will drop points within the quadrature scheme that had NA-values
PPM1_SLICE_corrected <- ppm(PPM1_SLICE_drop ~ pca1_SLICE_im_km) 
plot(effectfun(PPM1_SLICE_corrected, "pca1_SLICE_im_km", se.fit=TRUE), main= "Poisson Point Process Model", 
     las=1)

PPM1_SLICE_corrected
#OVERALL: lambda(i) = e^(-0.09 + 0.34)
#OVERAL: for every increase in one unit of the PCA1 density, the RTS point density increases by a factor of e^(-0.09 + 0.34) units

#SLICE: lambda(i) = e^(-6.26 + 2.3)
#SLICE: for every increase in one unit of the PCA1 density, the RTS point density increases by a factor of e^(-6.26 + 2.3)
```

```{r computing with dimyx}
dim(pca1_im_km)
rho_SLICE <- rhohat(ppp2_km, pca1_SLICE_im_km, method = "ratio", dimyx = 5000)
plot(rho_SLICE, las=1, main = "rho vs covariate with dimyx")

pred <- predict(rho_SLICE)
cl   <- interp.colours(c("lightyellow", "orange" ,"red"), 100) # Create color scheme
plot(pred, col=cl, las=1, main=NULL, gamma = 0.25)

K1 <- density(ppp2_km, dimyx = 5000)
K1_vs_pred <- pairs(K1, pred, plot = FALSE)
plot(K1_vs_pred$pred ~ K1_vs_pred$K1, pch=20,
     xlab = "Observed intensity", 
     ylab = "Predicted intensity", 
     col = rgb(0,0,0,.2),
     main = "Predicted intensity vs Observed intensity w/ 1 to 1 diagonal") + abline(a=0, b = 1, col = "red")
summary(as.data.frame(K1_vs_pred))

PPM1_SLICE <- ppm(ppp2_km ~ pca1_SLICE_im_km)
plot(effectfun(PPM1_SLICE, "pca1_SLICE_im_km", se.fit=TRUE), main=NULL, 
     las=1)

PPM1_SLICE_drop <- quad.ppm(PPM1_SLICE, drop=TRUE) #this step will drop points within the quadrature scheme that had NA-values
PPM1_SLICE_corrected <- ppm(PPM1_SLICE_drop ~ pca1_SLICE_im_km) 
plot(effectfun(PPM1_SLICE_corrected, "pca1_SLICE_im_km", se.fit=TRUE), main= "Poisson Point Process Model", 
     las=1)

PPM1_SLICE_corrected
```
